# 메모리 <!-- omit from toc -->

- [JS의 메모리 구성](#js의-메모리-구성)
- [가비지 콜렉터](#가비지-콜렉터)
- [React에서 흔히 발생하는 메모리 누수 사례](#react에서-흔히-발생하는-메모리-누수-사례)

현대 자바스크립트 엔진은 **인터프리터 + JIT 컴파일러 하이브리드 방식**이다.

자바스크립트를 실행하면 런타임 환경에 의해 파싱 → 바이트코드 생성 → 실행(+ JIT 컴파일) 과정을 거친다.
이 과정에서 실행에 필요한 코드와 데이터가 메모리에 로드되고, 자주 사용되는 코드는 최적화된 머신코드로 컴파일된다.
그래서 JS는 인터프리터처럼 시작하지만, 실행 도중 JIT이 개입해서 점점 빨라지는 실행 모델을 가진다.

## JS의 메모리 구성

- 스택 (Call Stack)
  - 저장 데이터: 함수 실행 컨텍스트(매개변수, this 바인딩, 외부 스코프 정보 등), 지역변수 원시값
  - 고정된 크기: 스택이 꽉 차면 스택 오버플로우 발생
  - 빠른 속도: 단순한 구조, 함수 실행과 종료시 자동으로 메모리에 올라오고 해제됨
- 힙 (Heap)
  - 저장 데이터
    - 객체/배열/함수와 같이 참조 타입의 실제 데이터 저장
    - 전역 객체도 저장 => **전역 변수는 전역 객체의 프로퍼티로 힙에 저장**
  - 가변 크기: 런타임에 동작 할당 가능
  - 느린 속도: 복잡한 구조, 가비지 컬렉터의 개입으로 비교적 느림

## 가비지 콜렉터

- 힙 메모리에 저장되어있는 참조 타입 데이터 중 불필요한 데이터를 자동으로 제거함
- 메모리 해제 기준
  - 단순히 참조 카운트가 0이면 해제하는 것이 아님
  - 도달 가능성, 즉 root 객체에서 시작해서, 해당 객체에 도달 가능한지(reachability) 여부를 판단함
- 엔진에서 적절한 시점에 주기적으로 실행함 => 타이밍을 정확히 제어할 수 없음

## React에서 흔히 발생하는 메모리 누수 사례

- 이벤트 리스너/타이머를 해제하지 않은 경우
  - `addEventListener`, `setInterval`, `setTimeout` 등록 후 컴포넌트가 언마운트 될 때 해제를 안하면 계속 메모리에 남음
- WebSocket, Subscription, Observer 같은 장기 연결 미해제
- DOM 참조를 명시적으로 해제하지 않은 경우
  - useRef로 DOM 요소나 큰 객체를 참조한 후 컴포넌트 언마운트 시 ref.current = null로 해제하지 않으면 GC 대상이 되지 않음
- 클로저에서 불필요한 큰 데이터를 참조하는 경우
  - useCallback, useMemo의 의존성 배열에 불필요한 큰 데이터를 포함하면 클로저가 해당 데이터를 계속 참조하여 메모리에서 해제되지 않음
