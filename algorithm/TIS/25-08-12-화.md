# [프로그래머스 Lv.1 - 자연수 뒤집어 배열로 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12932)

Last edited: 2025-08-12-화

- [프로그래머스 Lv.1 - 자연수 뒤집어 배열로 만들기](#프로그래머스-lv1---자연수-뒤집어-배열로-만들기)
  - [문제 설명](#문제-설명)
  - [초기 접근](#초기-접근)
  - [문제](#문제)
  - [생각](#생각)
  - [해결](#해결)

## 문제 설명

자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.

**제한사항**

- n은 10,000,000,000이하인 자연수입니다.

**예시**

- N = 12345 → [5,4,3,2,1]

## 초기 접근

어제 푼 '자릿수의 합 구하기' 문제와 같은 방식으로 풀 수 있는 문제. 자리수를 뒤집어야 하니 뒤에서부터 읽거나, 나머지를 이용한 연산으로 구하면 된다.

두가지 방식으로 풀어봤다.

첫번째, 숫자->문자열로 변환해서 푸는 방법. 정수를 문자열로 변환하고 뒤에서부터 순회하면서 배열에 넣는다.

```javascript
function solution(n) {
  let arr = [];
  let str = String(n);

  for (let i = str.length - 1; i >= 0; i--) {
    arr.push(Number(str[i]));
  }

  return arr;
}
```

두번째, 숫자 연산으로 푸는 방법. 정수를 10으로 나눠가며 나머지를 배열에 넣는다.

```javascript
function solution(n) {
  let arr = [];

  while (n > 0) {
    arr.push(n % 10);
    n = Math.floor(n / 10);
  }

  return arr;
}
```

**복잡도 분석**

- 시간 복잡도: **O(k)** (k = 자릿수)
- 공간 복잡도: **O(k)** (문자열 및 배열 생성)

## 문제

숫자->문자열 변환 방식을 절차형 접근이 아닌 선언형 접근(함수형 프로그래밍 스타일)으로 작성해보면 어떨까?

- 절차형보다 함수형이 가독성이 더 좋은 것 같다.
- 왜 함수형이 가독성이 더 좋다고 생각했을까? 함수형의 단점은?

## 생각

```javascript
// 절차형
let arr = [];
let str = String(n);
for (let i = str.length - 1; i >= 0; i--) {
  arr.push(Number(str[i]));
}

// 함수형
arr = String(n).split("").reverse().map(Number);
```

함수형 스타일

- 장점
  - 의도를 한 눈에 볼 수 있음
    - 절차형: **어떻게** 처리하는지 한 줄씩 읽어야 함
    - 함수형: **무엇을** 하고 싶은지 나열
      - 문자열을 -> 나누고 -> 뒤집고 -> 숫자로 변환
  - 코드 양이 줄어듬
    - 변수 선언, 인덱스 제어 코드 불필요
  - 버그 발생 가능성 감소
    - 인덱스 증가/감소, 경계 조건(`i >= 0` 등) 실수를 줄임
  - 조합 가능성
    - `map`, `filter`, `reduce` 같은 고차 함수는 체이닝으로 기능을 쉽게 조합할 수 있다.
- 단점
  - 각 메서드가 새로운 배열을 반환하기 때문에, **반복문 한 번에 끝낼 수 있는 작업을 여러 번 순회할 수 있음** (대부분의 경우에서는 무시해도 될 정도지만 데이터가 수백만 건일 때는 고려해야 함)
  - 체이닝이 너무 길어지면 가독성 저하

## 해결

```javascript
// 숫자->문자열 변환 방식: 가독성면에서 더 직관적임
function solution(n) {
  return String(n).split("").reverse().map(Number);
}
```

```javascript
// 숫자 연산 방식: 문자열 변환없이 처리할 수 있음
let arr = [];

while (n > 0) {
  arr.push(n % 10);
  n = Math.floor(n / 10);
}

return arr;
```
