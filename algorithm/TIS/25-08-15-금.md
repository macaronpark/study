# [프로그래머스 Lv.1 - x만큼 간격이 있는 n개의 숫자](https://school.programmers.co.kr/learn/courses/30/lessons/12954)

Last edited: 2025-08-15-금

- [프로그래머스 Lv.1 - x만큼 간격이 있는 n개의 숫자](#프로그래머스-lv1---x만큼-간격이-있는-n개의-숫자)
  - [문제 설명](#문제-설명)
  - [초기 접근](#초기-접근)
  - [문제](#문제)
  - [생각](#생각)
    - [1. 요소, 원소, 값, 인덱스](#1-요소-원소-값-인덱스)
    - [2. 배열 생성 패턴](#2-배열-생성-패턴)
    - [3. `for`로 푸는 방식과 다른 방식의 성능 차이점](#3-for로-푸는-방식과-다른-방식의-성능-차이점)
  - [해결](#해결)

## 문제 설명

함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.

**제한사항**

- x는 -10000000 이상, 10000000 이하인 정수입니다.
- n은 1000 이하인 자연수입니다.

**예시**

| x   | n   | answer       |
| --- | --- | ------------ |
| 2   | 5   | [2,4,6,8,10] |
| 4   | 3   | [4,8,12]     |
| -4  | 2   | [-4, -8]     |

## 초기 접근

```javascript
function solution(x, n) {
  let arr = [];

  for (let i = 1; i <= n; i++) {
    arr.push(i * x);
  }

  return arr;
}
```

```javascript
function solution(x, n) {
  return Array.from({ length: n }).map((_, i) => x * (i + 1));
}
```

**복잡도 분석**

- 시간 복잡도: **O(n)** n개의 요소를 한 번씩 계산
- 공간 복잡도: **O(n)** arr 배열에 n개의 정수 저장

## 문제

1. 프로그래밍에서 요소와 원소는 같은 의미로 사용되나?
2. 배열을 생성하는 더 좋은 방법?
3. `for`로 푸는 방식과 다른 방식의 성능 차이점?

## 생각

### 1. 요소, 원소, 값, 인덱스

- 요소(Element)와 원소(Element)
  - 프로그래밍에서는 거의 같은 뜻으로 사용
  - 배열(Array), 집합(Set), 리스트(List) 등 자료 구조안에 들어있는 하나의 값
  - 예: HTML 요소, 배열 요소
- 값(Value)
  - 변수에 저장된 실제 데이터
  - 예: 배열의 요소 `arr[0]` 의 값은 10
- 인덱스(Index)
  - 배열이나 문자열 등에서 각 요소가 위치한 번호

### 2. 배열 생성 패턴

- `Array.from(arrayLike, mapFn, thisArg)`: 순회 가능 또는 유사 배열 객체에서 얕게 복사된 새로운 Array 인스턴스 생성
  ```javascript
  Array.from({ length: n }, (_, i) => x * (i + 1)); // O
  Array.from({ length: n }).map((_, i) => x * (i + 1)); // X
  ```
- `Array()`, `new Array()`: new을 붙이든 안붙이든 새 Array 인스턴스 생성
- `Array.prototype.fill(value, start, end)`: 배열의 인덱스 범위 내 모든 요소를 정적 값으로 변경 후 수정된 배열 반환
  ```javascript
  Array(n)
    .fill(x)
    .map((v, i) => v * (i + 1));
  ```

### 3. `for`로 푸는 방식과 다른 방식의 성능 차이점

n이 작을 때(예: 1000개 내외) 체감이 거의 없음

- `for`: 순회하며 값 쓰기 => 1패스
- `Array.from({length:n}, mapper)`: 순회하며 mapper 호출해 값 쓰기 => 1패스 (중간 배열 없음)
- `Array(n).fill(...).map(...)`: 배열 전체를 특정 값으로 채우기 -> map으로 새 배열 생성 => 2패스

## 해결

N/A
