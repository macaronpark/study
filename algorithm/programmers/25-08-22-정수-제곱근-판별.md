- [문제 설명](#문제-설명)
- [초기 접근](#초기-접근)
- [문제](#문제)
- [생각](#생각)
  - [제곱근(square root)](#제곱근square-root)
- [부동소수점](#부동소수점)
- [해결](#해결)

<br>

## 문제 설명

[프로그래머스 Lv.1 - 정수 제곱근 판별](https://school.programmers.co.kr/learn/courses/30/lessons/12934)

- 설명

  - 임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.

- 제한사항

  - n은 1이상, 50000000000000 이하인 양의 정수입니다.

- 예시

  | n   | return |
  | --- | ------ |
  | 121 | 144    |
  | 3   | -1     |

<br>

## 초기 접근

```javascript
function solution(n) {
  const sqrt = Math.sqrt(n);

  return Number.isInteger(sqrt) ? (sqrt + 1) ** 2 : -1;
}
```

**복잡도 분석**

- 시간 복잡도: **O(1)** n에 대해 정해진 수의 연산 수행
- 공간 복잡도: **O(1)** 상수 크기의 변수 사용

<br>

## 문제

- 제곱근이란?
- 부동소수점 오차 가능성?

<br>

## 생각

### 제곱근(square root)

- x의 제곱근
  - 제곱했을 때 원래 수가 되는 값
  - n을 제곱했을 때 x가 되는 n값
  - x = n^2
    ```javascript
    Math.sqrt(9); // 3
    Math.sqrt(2); // 1.4142135...
    ```

## 부동소수점

- 컴퓨터가 소수(소수점이 있는 수)를 저장하는 방식
- 근본적으로 오차가 생길 수 밖에 없는 구조
  - 정수(int)는 딱 떨어지는 값이라 2진수로 정확히 표현 가능
  - 대부분의 소수는 2진수로 정확히 표현 안됨 -> 근사치로 잘라 저장
    ```javascript
    (0.1).toString(2);
    // '0.0001100110011001100110011001100110011001100110011001101'
    ```
- 오늘날 거의 모든 언어가 IEEE-754라는 표준을 사용해 소수 저장
  - `double` (배정도, 64비트) 기준
    - 1비트: 부호(+, -)
    - 11비트: 지수
    - 52비트: 유효숫자(소수 부분)
  - 유효숫자가 **15~16자리까지만 정확**하고, 그 이후는 잘릴 수 있음
- 부동소수점을 안전하게 다루는 방법
  - 정수 연산으로 재검증
    - 대부분의 경우 유효 범위를 넘는 경우가 많이 없겠지만 안정성을 위한 방어적 처리

<br>

## 해결

```javascript
function solution(n) {
  const r = Math.floor(Math.sqrt(n));

  // 부동소수점 오차 가능성을 정수 곱 비교로 방어
  return r * r === n ? (r + 1) ** 2 : -1;
}
```
