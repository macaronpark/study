- [문제 설명](#문제-설명)
- [초기 접근](#초기-접근)
- [문제와 생각](#문제와-생각)
  - [1. 불필요한 중복 대입](#1-불필요한-중복-대입)
  - [2. 불필요하게 오래 도는 케이스](#2-불필요하게-오래-도는-케이스)
- [해결](#해결)

<br>

## 문제 설명

[프로그래머스 Lv.1 - 콜라츠 추측](https://school.programmers.co.kr/learn/courses/30/lessons/12943)

- 설명
  - 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.
    - 1-1. 입력된 수가 짝수라면 2로 나눕니다.
    - 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.
    - 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.
  - 예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.
- 제한사항
  - 입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.
- 예시
  | n | result |
  | ------ | ------ |
  | 6 | 8 |
  | 16 | 4 |
  | 626331 | -1 |

<br>

## 초기 접근

```javascript
function solution(num) {
  let count = 0;

  while (num > 1) {
    num = num % 2 === 0 ? (num = num / 2) : (num = num * 3 + 1);
    count++;
  }

  return count >= 500 ? -1 : count;
}
```

**복잡도 분석**

- 시간 복잡도: **O()**
- 공간 복잡도: **O(1)**

<br>

## 문제와 생각

### 1. 불필요한 중복 대입

```javascript
// 문제
num = num % 2 === 0 ? (num = num / 2) : (num = num * 3 + 1);

// 해결
num = num % 2 === 0 ? num / 2 : num * 3 + 1;
```

### 2. 불필요하게 오래 도는 케이스

- 조건: 500번 반복할 때까지 1이 되지 않으면 바로 -1을 반환해야 함
- 문제: 초기 접근에서는 무조건 1까지 돌고 나서 count가 500 이상인지 확인하고 있어서 비효율적임
- 해결: while 내부에 조건을 작성하려고 함 => 종료 조건을 루프 헤더에 작성하면 더 깔끔함

<br>

## 해결

```javascript
function solution(num) {
  let count = 0;

  while (num > 1 && count < 500) {
    num = num % 2 === 0 ? num / 2 : num * 3 + 1;

    count++;
  }

  return num === 1 ? count : -1;
}
```
