- [문제 설명](#문제-설명)
- [초기 접근](#초기-접근)
- [문제와 생각](#문제와-생각)
- [해결](#해결)

<br>

## 문제 설명

[프로그래머스 Lv.2 - 타겟 넘버](https://school.programmers.co.kr/learn/courses/30/lessons/43165)

- 설명
  - n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.
    ```
    -1+1+1+1+1 = 3
    +1-1+1+1+1 = 3
    +1+1-1+1+1 = 3
    +1+1+1-1+1 = 3
    +1+1+1+1-1 = 3
    ```
  - 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.
- 제한사항
  - 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
  - 각 숫자는 1 이상 50 이하인 자연수입니다.
  - 타겟 넘버는 1 이상 1000 이하인 자연수입니다.
- 예시

  | numbers         | target | return |
  | --------------- | ------ | ------ |
  | [1, 1, 1, 1, 1] | 3      | 5      |
  | [4, 1, 2, 1]    | 4      | 2      |

<br>

## 초기 접근

- DFS/BFS 개념 학습
  - DFS(Depth-First Search)
    - 한 방향으로 끝까지 파고들어가서 더 이상 갈 수 없으면 되돌아오는 방식
    - 깊이 들어갔다가 되돌아와야 하므로 나중에 들어간 것을 먼저 처리하는 스택이 적합
  - BFS(Breadth-First Search)
    - 현재 위치에서 인접한 모든 곳을 먼저 확인하고, 그 다음 단계로 넘어가는 방식
    - 같은 레벨을 모두 처리한 후 다음 레벨로 가야 하므로 먼저 들어간 것을 먼저 처리하는 큐가 적합

<br>

## 문제와 생각

- 첫 숫자의 분기가 +, - 두 가지인데 루트는 하나만 잡아야하는게 아닌지?
  - 그래프의 루트란
    - 아무 것도 선택하지 않은 **초기 상태**
    - 모든 탐색은 **동일한 시작점에서 출발함**
    - (0, 0)부터 시작하면 됨

<br>

## 해결

```javascript
function solution(numbers, target) {
  let count = 0;

  function dfs(index, currentSum) {
    if (index === numbers.length) {
      if (currentSum === target) {
        count++;
      }
      return;
    }

    dfs(index + 1, currentSum + numbers[index]);
    dfs(index + 1, currentSum - numbers[index]);
  }

  dfs(0, 0);

  return count;
}
```

- 시간 복잡도: **O(2^n)**
  - 각 숫자마다 +, - 두 가지 경우의 수
  - n개 숫자 -> 2^n개 조합
  - 모든 조합을 탐색해야 함
- 공간 복잡도: **O(n)**
  - 재귀 호출 스택의 최대 깊이 = n
  - 각 스택 프레임은 O(1) 공간 사용
  - 총 공간 O(n)
