- [문제](#문제)
- [초기 접근](#초기-접근)
- [문제](#문제-1)
- [생각](#생각)
  - [1. `parseFloat()`, `Number()`, `+` 의 차이점](#1-parsefloat-number--의-차이점)
  - [2. 내장 함수없이 풀어보기](#2-내장-함수없이-풀어보기)
- [해결](#해결)

<br>

## 문제

[프로그래머스 Lv.1 - 문자열을 정수로 바꾸기](https://school.programmers.co.kr/learn/courses/30/lessons/12925)

- 설명

  - 문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요.

- 제한사항

  - s의 길이는 1 이상 5이하입니다.
  - s의 맨앞에는 부호(+, -)가 올 수 있습니다.
  - s는 부호와 숫자로만 이루어져있습니다.
  - s는 "0"으로 시작하지 않습니다.

- 예시

  - 예를들어 str이 "1234"이면 1234를 반환하고, "-1234"이면 -1234를 반환하면 됩니다.
  - str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다.

<br>

## 초기 접근

```javascript
function solution(s) {
  return +s;
}
```

**복잡도 분석**

- 시간 복잡도: **O(1)** 문자열을 정수로 변환하는 연산은 문자열 길이에 비례하므로 O(n) (n = 문자열 길이) 인데, 제한 조건 최대 5자라서 사실상 O(1)
- 공간 복잡도: **O(1)** 추가 변수, 자료구조 사용하지 않음

<br>

## 문제

1. `parseFloat()`, `Number()`, `+` 의 차이점?
2. 내장 함수없이 풀어보면 어떨까?

<br>

## 생각

### 1. `parseFloat()`, `Number()`, `+` 의 차이점

- 선/후행 공백: `" 123 "`

  - 세 가지 다 변환 가능

- 선행 0: `"000123"`

  - 세 가지 다 변환 가능

- 변환되지 않는 문자열: `"123abc"` / `"zz123abc"`

  - parseFloat("123abc") → 123
  - parseFloat("zz123abc") → NaN
    - 앞에서부터 읽을 수 있는 숫자까지만 변환
  - Number("123abc") / +("123abc") → NaN
    - 전체가 숫자여야 함

- 빈 문자열: `""`

  - parseFloat("") → NaN
  - Number("") / +("") → 0

### 2. 내장 함수없이 풀어보기

부호 여부를 검사하고, 부호가 있다면 부호를 뺀 수를 준비해서 자리수에 맞게 더해주면 됨

- 부호 체크 방식
  - sign 변수로 양수면 1, 음수면 -1을 할당해 최종 값에 곱해서 반환
- 왼쪽에서 오른쪽으로 숫자를 읽으면서 정수 만들기
  - `sum = sum \* 10 + digit`

<br>

## 해결

```javascript
function solution(s) {
  let sign = 1;
  let i = 0;

  if (s[0] === "-") {
    sign = -1;
    i = 1;
  } else if (s[0] === "+") {
    i = 1;
  }

  let sum = 0;

  for (; i < s.length; i++) {
    const d = s.charCodeAt(i) - 48;
    sum = sum * 10 + d;
  }

  return sign * sum;
}
```
