- [문제 설명](#문제-설명)
- [초기 접근](#초기-접근)
- [문제와 생각](#문제와-생각)
  - [`+=` 연산의 비효율성](#-연산의-비효율성)
- [해결](#해결)

<br>

## 문제 설명

[프로그래머스 Lv.1 - 핸드폰 번호 가리기](https://school.programmers.co.kr/learn/courses/30/lessons/12948)

- 설명
  - 프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다.
    전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 \*으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.
- 제한사항
  - phone_number는 길이 4 이상, 20이하인 문자열입니다.
- 예시
  | phone_number | return |
  | ------------- | -------------------- |
  | "01033334444" | "\*\*\*\*\*\*\*4444" |
  | "027778888" | "\*\*\*\*\*8888" |

<br>

## 초기 접근

```javascript
function solution_1(s) {
  let result = "";
  for (let i = 0; i < s.length; i++) {
    result += i < s.length - 4 ? "*" : s[i];
  }

  return result;
}
```

- 시간 복잡도: **O(n)** 문자열 길이만큼 순회
- 공간 복잡도: **O(n)** 새 문자열 저장하므로 입력 크기만큼 공간 필요

<br>

```javascript
function solution_2(s) {
  return "*".repeat(s.length - 4) + s.slice(-4);
}
```

- 시간 복잡도: **O(n)** `s.length - 4`만큼 순회
- 공간 복잡도: **O(n)** 새 문자열 저장하므로 입력 크기만큼 공간 필요

<br>

## 문제와 생각

### `+=` 연산의 비효율성

- JS 문자열은 primitive 원시 타입이고 immutable임
  - immutable => 한 번 만들어진 문자열 자체는 바뀌지 않음
  - 문자열은 불변이라 += 할 때마다 새 문자열을 복사/생성 → 성능/메모리 낭비
- `+=`의 실제 동작
  ```js
  let hello = "Hello";
  hello += " world";
  ```
  - (1) `hello` 변수와 별도인, 새로운 빈 메모리 공간을 만듦
  - (2) "Hello"를 복사하고 " world"를 이어붙여서 "Hello world"라는 새로운 문자열을 완성함
  - (3) `hello` 변수가 이 새로운 문자열을 가리키도록 다시 할당함
- `+=`의 문제점
  - 반복 횟수 많거나 문자열 길이가 커질 때 비효율적 => 이번 문제와 같이 최대 20자인 경우에는 해당 없음
  - 대체 방법: 배열 + `Array.join()`, `Template literal`
- [freeCodeCamp - How to Work with Strings in JavaScript – Tips for Efficient String Concatenation](https://www.freecodecamp.org/news/efficient-string-building-in-javascript)

<br>

## 해결

N/A
