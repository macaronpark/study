- [문제](#문제)
- [초기 접근](#초기-접근)
- [문제](#문제-1)
- [생각](#생각)
- [해결](#해결)

<br>

## 문제

[프로그래머스 Lv.1 - 약수의 합](https://school.programmers.co.kr/learn/courses/30/lessons/12928)

- 설명

  - 정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.

- 제한사항

  - n은 0 이상 3000이하인 정수입니다.

- 예시

  | n   | return |
  | --- | ------ |
  | 12  | 28     |
  | 5   | 6      |

<br>

## 초기 접근

- `i * i <= n`인 `i`까지만 검사하면서 `i`와 약수 쌍을 더한다.
- 놓쳤던 포인트: 동일한 수의 약수를 중복으로 더하는 실수가 있었다.

```javascript
function solution(n) {
  let sum = 0;

  for (let i = 1; i * i <= n; i++) {
    if (n % i === 0) {
      sum += i;

      const share = n / i;
      if (share === i) break;

      sum += share;
    }
  }

  return sum;
}
```

**복잡도 분석**

- 시간 복잡도: **O(√n)** 루프가 i = 1..⌊√n⌋까지만 돈다
- 공간 복잡도: **O(1)** 상수 크기의 sum, i, share 변수만 사용

<br>

## 문제

1. 코드 가독성을 높이는 법?
2. 시간 복잡도가 `O(√n)`인 이유?
3. 약수 관련 문제에서 체크해야 할 특이 케이스?

<br>

## 생각

### 1. 코드 가독성을 높이는 법

- 특례를 명시해보기
  - 예: n이 0인 경우, 바로 0 반환하기
- 의도 전달이 더 명확한 쪽으로 코드를 작성해보기

### 2. 시간 복잡도가 `O(√n)`인 이유

- 제곱(²)
  - 어떤 수를 자기 자신과 곱하는 것
  - 5² = 5 × 5 = 25
- 제곱근(√)
  - 어떤 수를 제곱했을 때 n이 되는 수
  - √25 = 5 (5² = 25)
- 약수는 쌍을 이루므로 `i * i <= n`인 i, 즉 `√n`개의 i만 검사
  - 예: n = 36이면, i = 1,2,3,4,5,6까지만 확인하고 멈춘다

### 3. 약수 관련 문제에서 체크해야 할 특이 케이스

- `n = 0` 약수가 없음
- `n = 1` 약수가 하나. {1}
- `n = 12` 약수 쌍. {(1,12), (2,6), (3,4)}
- `n = 25` 완전제곱수. {1,5,25} 중 5는 한 번만
- `n = 5` 소수. {1,5}

<br>

## 해결

```javascript
function solution(n) {
  if (n === 0) return 0; // 특례 처리

  let sum = 0;

  for (let i = 1; i * i <= n; i++) {
    if (n % i === 0) {
      sum += i;

      const share = n / i;
      if (share !== i) {
        // 완전제곱수 중복 방지
        sum += share;
      }
    }
  }

  return sum;
}
```
