- [문제 설명](#문제-설명)
- [초기 접근](#초기-접근)
- [문제와 생각](#문제와-생각)
- [해결](#해결)

<br>

## 문제 설명

[프로그래머스 Lv. 1 - 가장 가까운 같은 글자](https://school.programmers.co.kr/learn/courses/30/lessons/142086#)

- 설명
  - 문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다. 예를 들어, s="banana"라고 할 때, 각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.
    - b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
    - a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
    - n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
    - a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.
    - n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.
    - a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.
  - 따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.
  - 문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.
- 제한사항
  - 1 ≤ s의 길이 ≤ 10,000
    - s은 영어 소문자로만 이루어져 있습니다.
- 예시

  | s        | result                  |
  | -------- | ----------------------- |
  | "banana" | [-1, -1, -1, 2, 2, 2]   |
  | "foobar" | [-1, -1, 1, -1, -1, -1] |

<br>

## 초기 접근

- 타겟 문자열로 값 찾기 => hashMap
- 이전 기록은 보관할 필요없고 바로 앞에 나왔던 인덱스만 알면 됨

```javascript
function solution(s) {
  let arr = [];
  let history = {};

  for (let i = 0; i < s.length; i++) {
    if (history[s[i]] !== undefined) {
      arr.push(i - history[s[i]]);
    } else {
      arr.push(-1);
    }

    history[s[i]] = i;
  }

  return arr;
}
```

- 시간 복잡도: **O(n)**
  - 입력 문자열 길이만큼 순회 => `O(n)`
  - 배열 push, 인덱스로 조회, Object key로 조회 => `O(1)`
- 공간 복잡도: **O(n)**
  - arr => `O(n)`
  - history => `O(1)` 고유한 문자의 개수 (알파벳 최대 26자)
  - i => `O(1)`

<br>

## 문제와 생각

- `s[i]`에 반복적으로 접근
  - 반복적으로 접근하는 값은 매번 직접 접근하기 보다는 변수를 만들어놓고 접근하면 더 효율적임
- `Map` 사용해보기
  - `history[s[i]] !== undefined` 보다 `history.has()`가 의미가 더 명확함
- `const arr = []`에 요소를 push 할 수 있는 이유
  - const로 선언한 변수는 재할당이 금지되지만, 배열이나 객체같은 참조 타입의 경우 변수에 저장된 참조(메모리 주소)가 변경되는 것만 막을 뿐 참조가 가리키는 객체의 내부 데이터는 자유롭게 수정할 수 있음

<br>

## 해결

```javascript
function solution(s) {
  const arr = [];
  const history = new Map();

  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    if (history.has(char)) {
      arr.push(i - history.get(char));
    } else {
      arr.push(-1);
    }

    history.set(char, i);
  }

  return arr;
}
```
