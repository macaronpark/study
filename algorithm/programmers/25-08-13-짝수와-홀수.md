- [문제](#문제)
- [초기 접근](#초기-접근)
- [문제](#문제-1)
- [생각](#생각)
  - [1. 시간 복잡도와 공간 복잡도가 O(1)인 이유](#1-시간-복잡도와-공간-복잡도가-o1인-이유)
  - [2. 비트 연산](#2-비트-연산)
- [해결](#해결)

<br>

## 문제

[프로그래머스 Lv.1 - 짝수와 홀수](https://school.programmers.co.kr/learn/courses/30/lessons/12937)

- 설명

  - 정수 num이 짝수일 경우 "Even"을 반환하고 홀수인 경우 "Odd"를 반환하는 함수, solution을 완성해주세요.

- 제한사항

  - num은 int 범위의 정수입니다.
  - 0은 짝수입니다.

- 예시
  - n = 3 -> "Odd"
  - n = 4 -> "Even"

<br>

## 초기 접근

```javascript
function solution(num) {
  if (num % 2 === 0) return "Even";
  return "Odd";
}
```

**복잡도 분석**

- 시간 복잡도: **O(1)**
- 공간 복잡도: **O(1)**

<br>

## 문제

1. 시간 복잡도와 공간 복잡도는 왜 O(1)일까?
2. 나머지를 활용한 단순 조건문이 아닌 다른 방식으로도 풀 수 있을까?

<br>

## 생각

### 1. 시간 복잡도와 공간 복잡도가 O(1)인 이유

- 시간 복잡도

  - `O(1)`은 입력 크기(n)에 상관없이 실행 시간이 항상 일정한 연산임
    - 반대로 `O(n)`은 입력 크기에 따라 실행 시간이 늘어나는 연산임
  - 주어진 num에 대해 항상 **나머지를 구하는 연산을 한 번** 실행하고 결과에 따라 고정 값을 반환함

- 공간 복잡도

  - 알고리즘이 실행될 때 추가로 필요한 메모리 양
    - 입력 크기(n)가 커질수록 필요한 메모리가 얼마나 늘어나는지를 의미
  - 예시 코드 분석
    - 입력 크기와 상관없이 필요한 메모리 양은 항상 일정함
      - `num`: 이미 전달받은 값 -> 추가 공간 아님
      - `num % 2`: 연산 결과를 임시 저장할 정도의 상수 크기 메모리만 사용
      - `"Even"`과 `"Odd"`: 문자열 2개는 고정된 메모리 크기

### 2. 비트 연산

- 장/단점

  - 장점
    - 성능: CPU에서 `%` 연산(나눗셈+나머지 계산)보다 비트 연산이 더 단순하고 빠름
      - 성능 극대화가 중요한 환경(임베디드, 대규모 연산 루프 등)에서 유리
  - 단점
    - 가독성: 비트 연산에 익숙하지 않은 사람은 `% 2`가 더 직관적임
      - 일반적인 알고리즘 문제나 협업 환경에서는 `% 2`가 가독성이 더 좋음

- `&` AND 연산

  - 두 숫자의 이진수 표현을 각 비트 단위로 비교해서 **둘 다 1인 비트만 1**로 만드는 방식
  - 모든 정수는 이진수로 표현할 수 있음
    - 짝수 -> 항상 마지막 비트가 `0` (2: 0010, 4: 0100, 8: 1000)
    - 홀수 -> 항상 마지막 비트가 `1` (1: 0001, 3: 0011, 5: 0101)

<br>

## 해결

```javascript
// % 연산 방식
function solution(num) {
  return num % 2 === 0 ? "Even" : "Odd";
}
```

```javascript
// 비트 연산 방식
function solution(num) {
  return num & 1 ? "Odd" : "Even";
}
```
