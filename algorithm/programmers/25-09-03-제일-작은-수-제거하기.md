- [문제 설명](#문제-설명)
- [초기 접근](#초기-접근)
- [문제와 생각](#문제와-생각)
  - [`filter()`가 `O(n)`인 이유](#filter가-on인-이유)
  - [`Math.min(...arr)` vs. `reduce`](#mathminarr-vs-reduce)
  - [최소값이 여러 개일 때 하나만 제거하는 방법](#최소값이-여러-개일-때-하나만-제거하는-방법)
- [해결](#해결)

<br>

## 문제 설명

[프로그래머스 Lv.1 - 제일 작은 수 제거하기](https://school.programmers.co.kr/learn/courses/30/lessons/12935)

- 설명
  - 정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.
- 제한사항
  - arr은 길이 1 이상인 배열입니다.
  - 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다.
- 예시

  | arr       | return  |
  | --------- | ------- |
  | [4,3,2,1] | [4,3,2] |
  | [10]      | [-1]    |

<br>

## 초기 접근

```javascript
if (arr.length === 1) return [-1];

const min = Math.min(...arr);
return arr.filter((n) => n !== min);
```

- 시간 복잡도: **O(n)** min, filter
- 공간 복잡도: **O(n)** filter

<br>

## 문제와 생각

### `filter()`가 `O(n)`인 이유

- `filter()`는 주어진 배열에서 필터된 요소 배열을 얕은 복사로 생성함
  - 원본 배열 변경 X, 항상 새로운 배열 반환
  - 전체 요소 순회

### `Math.min(...arr)` vs. `reduce`

- `Math.min(...arr)`의 동작 방식
  - spread 연산자는 배열을 개별 인자로 펼쳐서 함수에 전달
    - `[4, 3, 2, 1]`을 그대로 쓰는 게 아니라 → `4, 3, 2, 1` 이렇게 각각의 값으로 복사해서 함수에 전달
- 문제점
  - 새로운 인자 리스트 생성: 배열 원소들을 풀어서 새 리스트를 만들기 때문에 배열이 커질수록 메모리를 많이 차지함
  - 호출 스택 제한: JS 엔진은 함수 호출 시 인자를 스택에 올리는데, 인자가 수십만 개 이상이면 스택 오버플로우가 발생할 수 있음
  - 불필요한 과정: spread 연산자는 중간에 값들을 풀어서 복사하는 과정을 추가로 거침
- 대안

  - `reduce`는 배열을 순차적으로 하나씩 처리함
  - spread 연산자처럼 추가로 배열을 풀어내는 동작이 없음

  ```javascript
  const min = arr.reduce((a, b) => Math.min(a, b));
  ```

### 최소값이 여러 개일 때 하나만 제거하는 방법

- min값을 구하고 배열 내 가장 처음 나오는 min값을 제거해야 하는 경우
- `arr.splice(시작위치, 삭제할개수, [추가할요소1, 추가할요소2...])`
  - 원본 배열을 직접 수정함 => 공간 복잡도 `O(1)`
  - 제거한 요소를 담은 배열을 반환. 제거한 값이 없다면 빈 배열 반환
  - `arr.splice(arr.indexOf(min), 1)`

<br>

## 해결

```javascript
function solution(arr) {
  if (arr.length === 1) return [-1];

  const min = arr.reduce((acc, cur) => Math.min(acc, cur));
  arr.splice(arr.indexOf(min), 1);
  return arr;
}
```

- 시간 복잡도: **O(n)** min, filter
- 공간 복잡도: **O(1)** splice => in-place
