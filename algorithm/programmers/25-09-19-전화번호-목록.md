- [문제 설명](#문제-설명)
- [초기 접근](#초기-접근)
- [문제와 생각](#문제와-생각)
  - [사전식 정렬](#사전식-정렬)
  - [접두어 검사](#접두어-검사)
  - [해시셋](#해시셋)
- [해결](#해결)

<br>

## 문제 설명

[프로그래머스 Lv.2 - 전화번호 목록](https://school.programmers.co.kr/learn/courses/30/lessons/42577)

- 설명
  - 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.
    - 구조대 : 119
    - 박준영 : 97 674 223
    - 지영석 : 11 9552 4421
  - 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.
- 제한사항
  - phone_book의 길이는 1 이상 1,000,000 이하입니다.
    - 각 전화번호의 길이는 1 이상 20 이하입니다.
    - 같은 전화번호가 중복해서 들어있지 않습니다.
- 예시

  | phone_book                        | return |
  | --------------------------------- | ------ |
  | ["119", "97674223", "1195524421"] | false  |
  | ["123","456","789"]               | true   |
  | ["12","123","1235","567","88"]    | false  |

<br>

## 초기 접근

- 못 품
  - 의도와 다른 메서드 사용
  - n^2으로 효율성 테스트 시간 초과

```javascript
function solution(p) {
  for (let i = 0; i < p.length; i++) {
    for (let j = 0; j < p.length; j++) {
      if (j !== i) {
        if (p[j].includes(p[i])) {
          return false;
        }
      }
    }
  }

  return true;
}
```

<br>

## 문제와 생각

### 사전식 정렬

- `sort()`를 사용하면 문자열 사전식 정렬을 할 수 있음
  - 접두어 관계라면, 짧은 문자열이 항상 앞에 옴
  - 따라서 인접한 요소만 비교하면 됨
  - 예: `["119", "97674223", "1195524421"]` -> `["119", "1195524421", "97674223"]`

### 접두어 검사

- `includes()`: 하나의 문자열이 다른 문자열에 포함되어 있는지를 검사
- `startsWith()`: 어떤 문자열의 문자로 시작하는지를 검사

### 해시셋

- `Set`은 해시 테이블로 구현됨
  - 해시 함수로 문자열을 숫자로 변환해서 저장
- `Set.has()`는 실질적으로 `O(1)`
  - 평균 `O(1)`, 최악 `O(n)`
  - 실제로는 거의 항상 `O(1)` (해시 충돌이 매우 드뭄)
- 정렬 비용이 없음. 입력이 매우 큰 경우 좋음

<br>

## 해결

```javascript
function solution(p) {
  p.sort();

  for (let i = 1; i < p.length; i++) {
    if (p[i].startsWith(p[i - 1])) {
      return false;
    }
  }

  return true;
}
```

- 시간 복잡도: **O(n log n \* k)** 정렬(n log n \* k), 루프(n \* k)
- 공간 복잡도: **O(n)** sort하면서 필요한 임시 메모리

---

```javascript
function solution(p) {
  const setPhoneBook = new Set(p);

  for (const phone of p) {
    for (let i = 1; i < phone.length; i++) {
      if (setPhoneBook.has(phone.slice(0, i))) {
        return false;
      }
    }
  }

  return true;
}
```

- 시간 복잡도: **O(n \* k^2)**
  - Set 생성: n개의 문자열 삽입, 해싱할 때 문자열 길이 k가 영향을 줌
  - 접두어 검사: n \* k^2
- 공간 복잡도: **O(n \* k)** Set: n, 문자열 길이 k
