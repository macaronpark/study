# 시간 복잡도

목차

- [시간 복잡도](#시간-복잡도)
  - [개념](#개념)
  - [Big-O 표기법](#big-o-표기법)
    - [`O(1)`](#o1)
    - [`O(n)`](#on)
    - [`O(n²)`](#on-1)
    - [`O(log n)`](#olog-n)
    - [`O(n log n)`](#on-log-n)
  - [주요 자료구조의 시간 복잡도 비교](#주요-자료구조의-시간-복잡도-비교)

## 개념

- 입력 크기 n이 커질수록 알고리즘이 얼마나 오래 걸리는지를 나타낸 것
- `O(1)`, `O(n)`, `O(n²)` 같이 **Big-O 표기법**으로 표현

## Big-O 표기법

입력 데이터가 n개일 때,

### `O(1)`

상수 시간: 입력 크기와 상관없이 항상 같은 시간

```javascript
// 배열의 첫 번째 원소만 보기
// - 아무리 배열이 길어도 항상 한 번만 작업 → O(1)
function getFirst(arr) {
  return arr[0];
}
```

### `O(n)`

선형 시간: 입력이 2배면 실행 시간도 2배

```javascript
// 배열에서 특정 숫자 찾기
// - 최악의 경우 배열을 끝까지 다 돈다 -> `O(n)`
// - 입력이 10개면 최대 10번 비교, 입력이 100개면 최대 100번 비교
function findNumber(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}
```

### `O(n²)`

제곱 시간: 입력이 2배면 실행 시간은 4배

```javascript
// 중첩 반목문이 있을 때
// - 최악의 경우 모든 루프를 끝까지 다 돈다
// - 바깥 루프: `n`번
// - 안쪽 루프: `n`번
// - 총 `n * n = n²`번 실행 → `O(n²)`
function printPairs(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      console.log(arr[i], arr[j]);
    }
  }
}
```

### `O(log n)`

로그 시간: 입력이 커져도 느리게 증가

### `O(n log n)`

효율적인 정렬 알고리즘들이 주로 이 시간

## 주요 자료구조의 시간 복잡도 비교

| 연산 종류                          | 배열 (`Array`)          | 객체 (`Object`)  | Set / Map     |
| ---------------------------------- | ----------------------- | ---------------- | ------------- |
| 접근 (`arr[i]`)                    | O(1)                    | X                | X             |
| 삽입 / 삭제                        | O(n) (중간/앞쪽일 경우) | O(1)             | O(1) _(평균)_ |
| 끝에 추가 (`push`)                 | O(1)                    | X                | O(1)          |
| 검색 (`includes`, 키 존재 여부 등) | O(n)                    | O(1) _(키 접근)_ | O(1)          |
| 정렬                               | O(n log n)              | X                | X             |

- 접근
  - 배열이 인덱스로 값에 O(1) 으로 접근할 수 있는 이유
  - 객체 / Set / Map이 "접근 X" 인 이유
- 삽입/삭제
  - 배열의 중간 삽입/삭제가 O(n)인 이유
  - 객체, Set, Map의 삽입/삭제가 O(1)인 이유
- [끝에 추가 (push)]
  - 배열이 O(1)인 이유
  - Object가 "X"인 이유
  - Set / Map의 O(1) 이유
