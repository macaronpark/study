# 정렬 알고리즘

- [정렬 알고리즘](#정렬-알고리즘)
  - [용어](#용어)
    - [In-place 알고리즘](#in-place-알고리즘)
    - [Stable sort](#stable-sort)
  - [Insertion sort](#insertion-sort)
  - [Merge sort](#merge-sort)
  - [Quick sort](#quick-sort)

## 용어

### In-place 알고리즘

- 추가 메모리를 거의 안 쓰고 원본 데이터 공간에서 바로 작업하는 알고리즘
  - 입력 크기에 비례하지 않는 상수 크기의 추가 메모리만 사용 (O(1) 공간)
  - 원본 데이터를 직접 수정해서 결과를 만듦 => 원본 보존 안 됨
- 예시
  - insertion sort: 원본 배열 내에서 정렬 수행 => 🟢 in-place
  - merge sort: 기존 배열에서 새로운 배열 생성 => ❌ NOT in-place

### Stable sort

- 동일한 값을 가진 요소들의 상대적 순서가 정렬 후에도 유지되는 정렬
- 예시
  - insertion sort: 같은 값일 때 뒤의 요소를 앞으로 이동시키지 않음 => 🟢 stable
  - quick sort: 피벗 기준으로 분할할 때 같은 값들의 순서가 바뀔 수 있음 => ❌ unstable

## Insertion sort

- 동작 원리: **찾아서 끼워넣기**
  - (1) 첫 번째 요소는 이미 정렬되어있다고 가정한다.
  - (2) 두 번째 요소부터, 왼쪽의 정렬된 부분에서 자신이 들어갈 위치를 찾는다.
  - (3) 해당 위치에 삽입하고, 나머지는 한 칸씩 밀어낸다.
  - (4) 마지막 요소까지 반복
- 특징
  - 시간 복잡도: 최선 `O(n)`, 평균/최악 `O(n²)`
  - in place 알고리즘
  - stable sort
- 유용한 경우
  - 데이터가 거의 정렬된 상태일 때 (시간 복잡도 최선 O(n))
  - 배열의 크기가 작을 때 (10-50개 이하)
  - 메모리가 제한적일 때

## Merge sort

- 동작 원리: **Divide and Conquer**
  - (1) 작은 조각으로 나눈다.
  - (2) 개별 조각을 해결한다.
  - (3) 조각을 합쳐 해결, 완료한다.
- 특징
  - 시간 복잡도: 최선/평균/최악 `O(n log n)`
  - stable sort: 기존 정렬이 유지되도록 구현할 수 있다.

## Quick sort

- 동작 원리: **Divide and Conquer**
  - (1) 배열에서 하나의 원소를 pivot으로 선택한다.
  - (2) 피벗보다 작다면 왼쪽, 같거나 크다면 오른쪽으로 분할
  - (3) 왼쪽과 오른쪽 부분을 각각 재귀로 퀵 소트
  - (4) 합쳐서 정렬 완료
- 특징
  - 시간 복잡도: 최선/평균 `O(n log n)`, 최악 `O(n²)`
  - unstable sort
